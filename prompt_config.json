{
    "agent": {
        "system_message": {
            "minimal": "You are a helpful workplace assistant that has access to multiple data sources (Slack, Gmail, Calendar, Jira, Drive) through function calling tools. You MUST use these tools to gather information before providing answers.",
            "detailed": "You are a helpful workplace assistant that has access to multiple data sources (Slack, Gmail, Calendar, Jira, Drive) through function calling tools. You MUST use these tools to gather information before providing answers. The clues needed to solve problems are hidden within these data sources - you need to explore them to find the necessary information. Review the descriptions of each available API and call the appropriate APIs to gather the information needed to solve the task. When solving tasks, consider information from multiple sources and make decisions based on a comprehensive view of all available data."
        },
        "user_message_instructions": {
            "minimal": {
                "tool_list": "You have access to the following tools: {tool_names}.",
                "tool_usage": "IMPORTANT: You MUST use the available tools to gather information before providing your final answer. Do not provide an answer without first calling the relevant tools to check calendars and other data sources.",
                "response_format": "After you have gathered all necessary information using the tools, provide your final answer in the following format:\n\nFinal Answer:\n[Your final answer here]\n\nIMPORTANT: When specifying dates and times in your answer, use the following formats:\n- Dates: YYYY-MM-DD format (e.g., 2025-12-02)\n- Times: HH:MM-HH:MM format (e.g., 14:00-14:45)\n\nRationale:\n[Your explanation here, including:\n- Which tools you used and why\n- What information you found from each source\n- How you applied any constraints or filters\n- Why you selected the final answer]"
            },
            "detailed": {
                "tool_list": "You have access to the following tools: {tool_names}.",
                "tool_usage": "IMPORTANT: You MUST use the available tools to gather information before providing your final answer. Do not provide an answer without first calling the relevant tools to check calendars and other data sources.",
                "date_range_hint": "If you're unsure about the exact date range, you can call calendar_query_freebusy without specifying start_date and end_date to search all available dates. This is often more reliable than guessing dates.",
                "calendar_warning": "The calendar data may not include all scheduling constraints. Other sources (Jira, Drive, Slack, Gmail) may contain additional information about time conflicts or constraints that are not reflected in the calendar. Always check these other sources to ensure a time slot is truly available and not excluded by other constraints.",
                "response_format": "After you have gathered all necessary information using the tools, provide your final answer in the following format:\n\nFinal Answer:\n[Your final answer here]\n\nIMPORTANT: When specifying dates and times in your answer, use the following formats:\n- Dates: YYYY-MM-DD format (e.g., 2025-12-02)\n- Times: HH:MM-HH:MM format (e.g., 14:00-14:45)\n\nRationale:\n[Your explanation here, including:\n- Which tools you used and why\n- What information you found from each source\n- How you applied any constraints or filters\n- Why you selected the final answer]"
            }
        }
    },
    "judge": {
    "system_prompt": "You are an evaluator that scores agent responses based on answer requirements satisfaction and source-grounded reasoning."
  },
  "data_generation": {
    "system_message": "You are a data generator that creates realistic workplace data. Generate natural, realistic content that meets the specified requirements.",
    "user_prompt_template": {
      "instructions": "Generate realistic, natural content that:",
      "requirements": [
        "Each piece is incomplete on its own (if fragmentation_depth >= 2)",
        "When combined, the distractor slots are excluded",
        "References the linked source appropriately (if indirection_depth >= 2)",
        "The content is realistic and natural depending on the source"
      ],
      "format_instructions": {
        "slack": "Return exactly {fragmentation_depth} messages. Format:\n- JSON array: [\"Message 1\", \"Message 2\", ...]\n- OR newline-separated: Message 1\\nMessage 2\\n...\nEach message should be incomplete on its own but together exclude the distractor slots.",
        "jira": "Return exactly {fragmentation_depth} issues. Format:\n- JSON array: [{\"description\": \"...\"}, ...]\n- OR newline-separated: Description 1\\nDescription 2\\n...\nEach description must be 10 sentences or less and should be incomplete on its own but together exclude the distractor slots.\n\nCRITICAL: Each issue description must be INCOMPLETE and feel like a brief note or comment, not a complete ticket.\n- Issue 1: Should contain only PARTIAL information (e.g., vague references, missing context, unclear details)\n- Issue 2: Should contain COMPLEMENTARY information needed to complete Issue 1\n- Together they should exclude distractor slots, but each alone should be insufficient\n- DO NOT create structured tickets with sections like 'Goal', 'Context', 'Tasks', 'Acceptance criteria'\n- Keep descriptions short, conversational, and realistic like actual Jira comments or quick notes\n\nExample of INCOMPLETE issues (GOOD - realistic Jira style):\nIssue 1: {\"description\": \"Checking availability for next week. There's a potential conflict on Tuesday afternoon. Need to confirm with the team.\"}\nIssue 2: {\"description\": \"The 2pm slot on Dec 2nd is blocked. See channel_000 in Slack for details. We should skip that time.\"}\n\nAnother GOOD example:\nIssue 1: {\"description\": \"Alice mentioned she can't do early morning next week. Need to find alternative times. Will check with Bob and Carol.\"}\nIssue 2: {\"description\": \"The 13:00-13:45 window on Wednesday is out. There's a conflict with another meeting. Tuesday 14:00-14:45 might work instead.\"}\n\nExample of COMPLETE issues (BAD - DO NOT DO THIS):\nIssue 1: {\"description\": \"Goal: Find meeting time. Context: We need to schedule... Tasks: 1. Check calendars 2. Confirm... Acceptance criteria: ...\"}\nIssue 2: {\"description\": \"Objective: Finalize meeting. Inputs: From previous issue... Tasks: 1. Review options 2. Send invite... Deliverables: ...\"}",
        "drive": "Return exactly {fragmentation_depth} file contents. Format:\n- JSON array: [{\"name\": \"...\", \"text\": \"...\"}, ...]\n- OR newline-separated: Content 1\\nContent 2\\n...\nEach file must be at least 30 sentences long.\nCRITICAL:\n- Only 1-2 sentences should be about scheduling/meeting times\n- The remaining 28+ sentences should be realistic workplace content related to the document title\n- Document titles should suggest the main topic (e.g., 'Project Planning Notes', 'Team Meeting Summary', 'Q4 Roadmap Discussion')\n- The scheduling information should be naturally embedded within the larger document context\nEach file content should be incomplete on its own but together exclude the distractor slots.",
        "gmail": "Return exactly {fragmentation_depth} email messages. Format:\n- JSON array: [{\"text\": \"...\"}, ...]\n- OR newline-separated: Message 1\\nMessage 2\\n...\nEach message should be incomplete on its own but together exclude the distractor slots."
      }
    },
    "source_descriptions": {
      "calendar": "Generate realistic calendar data for the given task.",
      "slack": "Generate realistic Slack messages for the given task.",
      "gmail": "Generate realistic Gmail threads for the given task.",
      "jira": "Generate realistic Jira issues for the given task. Each issue should be a brief, incomplete note or comment (10 sentences or less) that references scheduling constraints. Think of these as quick notes or partial updates rather than complete, well-structured tickets. They should feel like someone quickly added a comment or created a minimal issue without full documentation.",
      "drive": "Generate realistic Drive document files. Each file must be at least 30 sentences long. The scheduling/meeting information should only occupy 1-2 sentences of the document. The majority of the content (28+ sentences) should be realistic workplace content related to the document title/name, such as project notes, meeting summaries, planning documents, or team updates."
    },
    "validation": {
      "system_message": "You are a validator that checks if generated data meets requirements.",
      "check_instructions": "Check:\n- Is each piece incomplete on its own? (fragmentation_depth >= 2)\n- When combined, are distractor slots excluded but canonical slots remain?\n- Is the content natural and realistic?\n- Are linked source references correct? (if applicable)",
      "response_format": "Respond with \"VALID\" if all checks pass, or \"INVALID: <reason>\" if any check fails."
    }
  },
  "generator": {
    "fallback_names": ["Alice", "Bob", "Carol", "Dave", "Eve"],
    "email_domain": "example.com",
    "linked_source_id_patterns": {
      "jira_issue_key": "{project_key}-{num}",
      "slack_channel_id": "channel_{num:03d}",
      "drive_file_id": "file_{num:03d}",
      "gmail_thread_id": "thread_{num:03d}"
    },
    "slack": {
      "default_channel": "general",
      "base_user_names": ["alice", "bob", "carol", "dave", "eve"],
      "channel_names": ["general", "team", "random"],
      "channel_descriptions": ["General discussion", "Team updates", "Random chat"]
    },
    "jira": {
      "project_keys": ["API", "DOC", "PROJ", "TEAM"],
      "project_names": ["API Project", "Documentation Project", "Project Management", "Team Collaboration"],
      "project_descriptions": ["API development project", "Documentation and guides", "Project tracking and planning", "Team coordination"]
    },
    "drive": {
      "folder_names": ["Documents", "Projects", "Team"],
      "folder_descriptions": ["General documents", "Project files", "Team resources"]
    },
    "calendar": {
      "timestamp_patterns": [
        "2025-11-20T09:00:00Z",
        "2025-11-20T10:00:00Z",
        "2025-11-20T11:00:00Z",
        "2025-11-21T09:00:00Z"
      ]
    },
    "gmail": {
      "from_candidates": ["alice@example.com", "bob@example.com", "carol@example.com"],
      "to_candidates": ["team@example.com", "all@example.com"]
    }
  },
  "tool_descriptions": {
    "calendar_list_events": {
      "minimal": "List calendar events for given email addresses within an optional date range.",
      "detailed": "List calendar events for given email addresses within an optional date range. Returns: {\"events\": [{\"email\": str, \"date\": \"YYYY-MM-DD\", \"slot\": \"HH:MM-HH:MM\", \"busy\": bool}]}. Each event shows whether a specific person is busy or free at a given time slot.\n\nUse cases:\n- When finding meeting times, you need to check each participant's calendar to see their availability. Listing events helps you understand individual schedules before calculating common free slots.\n- Events with busy=true indicate time slots when a person is unavailable. Events with busy=false show when they are free.\n- If you need to understand why certain time slots are unavailable, inspecting individual events can reveal specific conflicts or commitments.\n\nExample: calendar_list_events(email_addresses=['alice@example.com'], start_date='2025-12-01') to see Alice's events for December 1st. After listing events, you can call calendar_query_freebusy() to find common free slots across multiple participants.\n\nImportant: The calendar data may not include all scheduling constraints. Other sources (Jira, Drive, Slack, Gmail) may contain additional information about time conflicts or constraints that are not reflected in the calendar events."
    },
    "calendar_query_freebusy": {
      "minimal": "Query common free time slots for multiple email addresses within an optional date range.",
      "detailed": "Query common free time slots for multiple email addresses. This internally fetches events and calculates when all participants are available. Returns: {\"time_slots\": [{\"date\": \"YYYY-MM-DD\", \"slot\": \"HH:MM-HH:MM\", \"participants\": [str]}]}. Each time slot indicates when all specified email addresses are free.\n\nUse cases:\n- When scheduling meetings with multiple participants, this function finds time slots when everyone is available simultaneously.\n- The returned time_slots show only periods where all specified participants have busy=false in their calendars.\n- If a task requires finding a meeting time that works for multiple people, this is typically the most efficient approach.\n- You can call this directly without first listing events, or use calendar_list_events() first if you need to inspect individual schedules.\n\nExample: calendar_query_freebusy(email_addresses=['alice@example.com', 'bob@example.com'], start_date='2025-12-01', end_date='2025-12-07') to find common free slots for Alice and Bob during the first week of December.\n\nImportant: The calendar data may not include all scheduling constraints. Other sources (Jira, Drive, Slack, Gmail) may contain additional information about time conflicts or constraints that are not reflected in the calendar. Always check these other sources to ensure a time slot is truly available and not excluded by other constraints."
    },
    "slack_list_channels": {
      "minimal": "List Slack channels.",
      "detailed": "List Slack channels. Returns: {\"channels\": [{\"channel_id\": str, \"name\": str}]}.\n\nUse cases:\n- When searching for information across Slack, knowing available channels helps you target your search to relevant channels.\n- Different channels may contain different types of discussions. For example, team channels might have scheduling discussions, while general channels might have broader conversations.\n- If you need to browse messages from a specific channel, first list channels to get the channel_id, then use slack_list_messages() with that channel_id.\n\nExample: slack_list_channels() to see all available channels, then use the channel_id to filter messages."
    },
    "slack_list_messages": {
      "minimal": "List Slack messages, optionally filtered by channel_id.",
      "detailed": "List Slack messages, optionally filtered by channel_id. If channel_id is not provided, returns messages from all channels. Returns: {\"messages\": [{\"message_id\": str (format: \"channel:index\"), \"channel_id\": str, \"text\": str, \"user\": str, \"timestamp\": str}]}.\n\nUse cases:\n- When team members discuss availability or preferences in Slack, their messages may contain time-related information (e.g., \"I can't do mornings next week\" or \"afternoons work better for me\").\n- Messages often contain references to documents or other resources that might have scheduling information. For example, someone might mention \"Check the API Design Doc for the meeting time.\"\n- If you need to understand team discussions about scheduling, browsing messages can reveal preferences, constraints, or previously discussed time slots.\n\nExample: slack_list_messages(channel_id='general') to get messages from the 'general' channel, or slack_list_messages() to see messages from all channels."
    },
    "slack_search_messages": {
      "minimal": "Search Slack messages by user name.",
      "detailed": "Search Slack messages by user name. Returns: {\"messages\": [{\"message_id\": str, \"channel_id\": str, \"text\": str, \"user\": str, \"timestamp\": str}]}. Returns messages sent by the specified user.\n\nUse cases:\n- When a task mentions specific participants (e.g., \"Find a meeting time for Alice, Bob, and Carol\"), you can search for messages from those people to see if they've discussed time preferences or constraints.\n- Team members often share their availability or scheduling preferences in Slack. Searching by user name helps you find messages from specific participants.\n- Messages from participants may contain time-related information, preferences, or references to documents that have scheduling information.\n- If you need to understand what a specific person has said about meeting times or constraints, search for their messages.\n\nExample: slack_search_messages(user_name='alice') to find messages from Alice, or slack_search_messages(user_name='bob') to find messages from Bob."
    },
    "slack_get_channel": {
      "minimal": "Get channel information by channel_id.",
      "detailed": "Get channel information by channel_id. Returns: {\"channel_id\": str, \"name\": str}.\n\nUse cases:\n- After listing channels, you may want to verify details about a specific channel before searching or listing its messages.\n- Channel names can help you identify which channels are most likely to contain relevant information for your task.\n- This is typically used as a verification step after slack_list_channels() to confirm you have the correct channel.\n\nExample: slack_get_channel(channel_id='channel_001') to get details about a specific channel."
    },
    "gmail_list_threads": {
      "minimal": "List Gmail threads, optionally filtered by search query.",
      "detailed": "List Gmail threads, optionally filtered by search query. Returns: {\"threads\": [{\"thread_id\": str, \"subject\": str}]}. If query is not provided, returns all threads.\n\nUse cases:\n- Email threads often contain scheduling discussions, cancellations, or availability updates. Threads with subjects like 'Schedule update', 'Meeting time change', or 'Availability update' may contain relevant information.\n- When team members communicate about meeting times via email, these conversations are preserved in threads. Searching for keywords related to scheduling can help you find relevant email discussions.\n- If a task involves checking for cancellations or changes to previously scheduled meetings, email threads are a common place where such information appears.\n- After finding a relevant thread, use gmail_get_thread() to read all messages in the conversation.\n\nExample: gmail_list_threads(query='meeting') to find threads containing 'meeting', or gmail_list_threads(query='cancel') to find cancellation-related threads."
    },
    "gmail_list_messages": {
      "minimal": "List Gmail messages across all threads, optionally filtered by search query.",
      "detailed": "List Gmail messages across all threads, optionally filtered by search query. Returns: {\"messages\": [{\"message_id\": str (format: \"thread_id:index\"), \"subject\": str}]}.\n\nUse cases:\n- Individual email messages may contain specific time-related information, such as cancellations (e.g., \"We can't do 2025-12-02 13:00-13:45 anymore\") or availability updates.\n- When searching for specific information across all email conversations, listing messages can help you quickly identify relevant emails without browsing entire threads.\n- Messages with subjects like 'Schedule update' or 'Time slot conflict' may contain information about time constraints or changes.\n- After finding a relevant message, use gmail_get_message() to read its full content.\n\nExample: gmail_list_messages(query='cancel') to find messages about cancellations, or gmail_list_messages(query='schedule') to find scheduling-related messages."
    },
    "gmail_get_thread": {
      "minimal": "Get thread details by thread_id.",
      "detailed": "Get thread details by thread_id. Returns: The full thread object from the data source, containing {\"thread_id\": str, \"subject\": str, \"messages\": [{\"from\": str, \"to\": [str], \"subject\": str, \"text\": str, \"timestamp\": str}]}.\n\nUse cases:\n- Email threads contain complete conversation histories. When scheduling discussions happen over multiple emails, reading the full thread helps you understand the complete context.\n- Threads may contain back-and-forth discussions about availability, preferences, or cancellations that span multiple messages.\n- If you found a relevant thread using gmail_list_threads(), use this function to read all messages in that conversation.\n- The full thread context is especially useful when trying to understand the evolution of scheduling decisions or identifying all mentioned time constraints.\n\nExample: gmail_get_thread(thread_id='thread_001') to read all messages in a specific thread."
    },
    "gmail_get_message": {
      "minimal": "Get message details by message_id.",
      "detailed": "Get message details by message_id. Returns: {\"message_id\": str, \"thread_id\": str, \"subject\": str, \"text\": str, \"from\": str, \"to\": [str], \"timestamp\": str}. Message IDs are in the format 'thread_id:index' (e.g., 'thread_001:0').\n\nUse cases:\n- After finding a relevant message using gmail_list_messages(), use this function to read its full content.\n- Individual messages may contain specific time-related information, such as exact cancellation times (e.g., \"We can't do 2025-12-02 13:00-13:45 anymore\").\n- Message text often contains detailed information about availability, constraints, or scheduling changes that might not be apparent from just the subject line.\n- If you need to extract specific time slots or constraints mentioned in an email, reading the full message text is necessary.\n\nExample: gmail_get_message(message_id='thread_001:0') to read a specific message from a thread."
    },
    "jira_list_projects": {
      "minimal": "List Jira projects.",
      "detailed": "List Jira projects. Returns: {\"projects\": [{\"project_key\": str, \"name\": str}]}.\n\nUse cases:\n- Before searching for issues, you may want to see what projects are available. Different projects may contain different types of work items or scheduling information.\n- If you need to filter issues by project, first list projects to get the project_key, then use jira_search_issues() with that project key.\n- Projects often organize work items, and issues within a project may contain scheduling or conflict information relevant to your task.\n\nExample: jira_list_projects() to see all available projects, then use the project_key with jira_search_issues() to filter issues."
    },
    "jira_search_issues": {
      "minimal": "Search Jira issues using JQL query or filters.",
      "detailed": "Search Jira issues using JQL query or filters. Returns: {\"issues\": [{\"issue_key\": str (e.g., \"API-121\"), \"summary\": str, \"status\": str}]}. You can use JQL syntax (e.g., 'status=Open'), or filter by project and status separately. If no filters provided, returns all issues.\n\nUse cases:\n- When planning meetings, team members may have scheduled work items or conflicts in Jira that affect their availability. Searching for issues with status='To Do' or 'In Progress' can reveal scheduled activities.\n- Issue summaries often contain time-related information (e.g., \"Team Sync scheduled for 2025-12-02 13:00-13:45\"). Reviewing summaries helps identify potential time conflicts.\n- If a task mentions checking for conflicts or constraints, Jira issues may contain relevant scheduling information.\n- Issues with status='To Do' or 'In Progress' are particularly relevant as they represent active work that might conflict with meeting times.\n\nExample: jira_search_issues(jql='status=To Do') to find all pending issues, or jira_search_issues(project='API', status='To Do') to filter by project."
    },
    "jira_get_issue": {
      "minimal": "Get issue details by issue_key.",
      "detailed": "Get issue details by issue_key. Returns: {\"issue_key\": str, \"summary\": str, \"description\": str, \"status\": str}. Issue keys are in the format 'PROJ-123' (e.g., 'API-121').\n\nUse cases:\n- After finding relevant issues using jira_search_issues(), use this function to read the full details of a specific issue.\n- Issue descriptions may contain additional time-related information beyond what's in the summary. For example, detailed scheduling information or constraints might be in the description.\n- If an issue summary mentions a time slot (e.g., \"Team Sync scheduled for 2025-12-02 13:00-13:45\"), reading the full issue can provide more context about the conflict or constraint.\n- Issue details help you understand the full scope of work items that might affect availability.\n\nExample: jira_get_issue(issue_key='API-121') to read the full details of a specific issue."
    },
    "jira_get_project": {
      "minimal": "Get project information by project_key.",
      "detailed": "Get project information by project_key. Returns: {\"project_key\": str, \"name\": str}.\n\nUse cases:\n- After listing projects, you may want to verify details about a specific project before searching its issues.\n- Project information helps you understand the context of issues within that project, which can be useful when filtering or searching for relevant work items.\n- This is typically used as a verification step after jira_list_projects() to confirm you have the correct project before searching issues.\n\nExample: jira_get_project(project_key='API') to get details about the API project."
    },
    "drive_list_files": {
      "minimal": "List Drive files, optionally filtered by search query.",
      "detailed": "List Drive files, optionally filtered by search query. Returns: {\"files\": [{\"file_id\": str, \"name\": str}]}. If query is not provided, returns all files.\n\nUse cases:\n- Documents in Drive may contain scheduling information or references to meeting times. For example, a document might mention \"The previous plan was to meet on 2025-12-02 17:00-17:45, but that time no longer works.\"\n- If Slack messages or other sources reference a specific document (e.g., \"Check the API Design Doc for the meeting time\"), search for that document using its name.\n- Drive files often contain project planning documents, meeting notes, or team coordination materials that may include time-related constraints or preferences.\n- After finding a relevant file, use drive_export_file() to read its content, as file text may contain important scheduling information.\n\nExample: drive_list_files(query='API Design Doc') to find a specific document, or drive_list_files(query='meeting') to find files related to meetings."
    },
    "drive_get_file": {
      "minimal": "Get file details by file_id.",
      "detailed": "Get file details by file_id. Returns: {\"file_id\": str, \"name\": str}. Note: This does NOT return file content. To get file content, use drive_export_file() instead.\n\nUse cases:\n- After finding files using drive_list_files(), you may want to verify file metadata before reading the content.\n- This function returns only file metadata (file_id and name). If you need to read the actual content of a file (which may contain scheduling information), use drive_export_file() instead.\n- File metadata can help you confirm you have the correct file before exporting its content.\n\nExample: drive_get_file(file_id='file_004') to get metadata for a specific file. To read the file content, use drive_export_file() with the same file_id."
    },
    "drive_export_file": {
      "minimal": "Export file content by file_id.",
      "detailed": "Export file content by file_id. Returns: {\"content\": str}. This is the text content of the file. File IDs are obtained from the file_id field in drive_list_files() or drive_get_file() results.\n\nUse cases:\n- Drive files may contain scheduling information in their text content. For example, a document might state \"The previous plan was to meet on 2025-12-02 17:00-17:45, but that time no longer works.\"\n- If Slack messages or other sources reference a document that might contain time-related information, export the file content to read the full text.\n- Documents often contain project planning details, meeting notes, or coordination materials that include constraints, preferences, or previously discussed time slots.\n- This is the only way to read the actual text content of a file. drive_get_file() only returns metadata.\n\nExample: drive_export_file(file_id='file_004') to read the full text content of a file. The content may contain time-related information that affects scheduling decisions."
    }
  }
}

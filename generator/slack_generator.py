"""Slack data generator module - reads plans from LLM-generated world_state."""

from typing import Dict, Any, List


def generate_slack_data(world_state: Dict[str, Any], slack_plans: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Generate a Slack workspace JSON document from world_state and slack_plans.
    Must conform to schemas/slack_schema.json.
    
    The slack_plans come from world_state.per_source_plans.slack_plans,
    which are generated by the LLM based on the scenario.
    """
    scenario_id = world_state.get("scenario_id", "scenario_A")
    workspace_name = f"{scenario_id.replace('_', ' ').title()} Workspace"
    
    # Build a person lookup by ID
    people_by_id = {person["id"]: person for person in world_state.get("people", [])}
    
    # Track channels and messages
    channels_dict = {}
    messages = []
    message_id = 1
    
    # Process each plan from LLM-generated per_source_plans
    for plan in slack_plans:
        # Plans should contain: channel, author_person_id, text, timestamp
        # The LLM is responsible for determining these based on the scenario
        
        channel_name = plan.get("channel", "#general")
        author_person_id = plan.get("author_person_id")
        text = plan.get("text", "")  # LLM-generated message text
        timestamp = plan.get("timestamp")  # ISO datetime string
        
        if not text or not author_person_id:
            continue
        
        # Ensure channel exists
        if channel_name not in channels_dict:
            channels_dict[channel_name] = {
                "id": f"C{len(channels_dict) + 1}",
                "name": channel_name
            }
        
        channel_id = channels_dict[channel_name]["id"]
        
        # Use timestamp from plan, or generate sequential if missing
        if not timestamp:
            # Fallback: generate sequential timestamps (generic, not scenario-specific)
            timestamp = f"2025-11-{7 + message_id}T10:00:00+09:00"
        
        # Create message
        messages.append({
            "id": f"M{message_id}",
            "channel_id": channel_id,
            "user_id": author_person_id,
            "text": text,
            "timestamp": timestamp
        })
        message_id += 1
    
    # Convert channels dict to list
    channels = list(channels_dict.values())
    
    # Create users list from world_state people
    users = [
        {
            "id": person["id"],
            "name": person["name"],
            "email": person["email"]
        }
        for person in world_state.get("people", [])
    ]
    
    return {
        "workspace_name": workspace_name,
        "channels": channels,
        "messages": messages,
        "users": users
    }
